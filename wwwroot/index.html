<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Eye Almanac — DM Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root {
            --panel-bg: #071827;
            --accent: #ffd880;
            --muted: #9fb7cc;
            --bg: #0b0b0f;
        }

        body {
            font-family: system-ui, Arial;
            margin: 12px;
            background: var(--bg);
            color: #e6eef8;
        }

        h2 {
            margin: 0 0 10px 0;
        }

        #wrap {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .panel {
            background: var(--panel-bg);
            padding: 12px;
            border-radius: 8px;
            min-width: 240px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.6);
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
        }

        input[type=number], input[type=text] {
            width: 100px;
            padding: 6px;
            margin-right: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.06);
            background: #0f222b;
            color: #e6eef8;
        }

        button {
            padding: 8px 10px;
            margin: 6px 4px 0 0;
            border-radius: 6px;
            background: #163247;
            color: #e6eef8;
            border: 0;
            cursor: pointer;
        }

            button.secondary {
                background: #0b2a2f;
            }

        .small {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        #canvas {
            border-radius: 6px;
            display: block;
            background: #061426;
            border: 1px solid #234;
            margin-top: 12px;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h2>The Eye — DM Dashboard</h2>

    <div id="wrap">
        <div class="panel" id="controls">
            <div><strong>Eye Metrics</strong></div>
            <div id="metrics" class="small">loading…</div>

            <label>Camp coords (km)</label>
            <div class="row">
                X: <input id="campX" type="number" value="0" step="0.1" />
                Y: <input id="campY" type="number" value="0" step="0.1" />
                <button id="centerCamp">Center on Eye</button>
            </div>
            <div class="small" id="inGameTimeDisplay">In-Game Time: loading...</div>

            <hr style="border: none; height:1px; background:#0e3244; margin:10px 0;" />

            <div><strong>Diameter</strong></div>
            <div class="row">
                <label style="margin:6px 0 0 0;">Set Diameter (km)</label>
                <input id="setDiameter" type="number" value="50" min="1" />
                <button id="setDiameterBtn">Set</button>
            </div>
            <div class="row" style="margin-top:6px;">
                <label style="margin:0 8px 0 0;">Shrink over time</label>
                Target: <input id="shrinkTarget" type="number" value="30" min="1" />
                Hours: <input id="shrinkHours" type="number" value="12" min="1" style="width:64px" />
                <button id="shrinkOverBtn">Start</button>
            </div>
            <div class="row" style="margin-top:8px;">
                <label style="margin:0 8px 0 0;">Instant shrink %</label>
                <input id="shrinkPercent" type="number" value="10" min="1" max="99" />
                <button id="shrinkNow">Shrink</button>
            </div>

            <hr style="border: none; height:1px; background:#0e3244; margin:10px 0;" />

            <div><strong>Time & Influence</strong></div>
            <div class="row">
                <label>Advance days</label>
                <input id="jumpDays" type="number" value="1" min="1" />
                <button id="jumpDaysBtn">Jump</button>
                <button id="advanceDay">+1 day</button>
            </div>

            <div style="margin-top:8px;"><strong>Influence (wind / push)</strong></div>
            <div class="row">
                <input id="infName" type="text" placeholder="name (optional)" />
                <input id="infDir" type="number" placeholder="deg" value="90" style="width:64px" />
                <input id="infMag" type="number" placeholder="km/day" value="5" style="width:80px" />
                <input id="infDur" type="number" placeholder="hours" value="72" style="width:80px" />
                <button id="applyInf">Apply</button>
            </div>

            <hr style="border: none; height:1px; background:#0e3244; margin:10px 0;" />

            <div><strong>Base / Surge / Ops</strong></div>
            <div class="row">
                <label>Set base (bearing°, km/day)</label>
                <input id="baseBearing" type="number" value="90" style="width:80px" />
                <input id="baseSpeed" type="number" value="12" style="width:80px" />
                <button id="setBase">Set</button>
            </div>
            <div class="row" style="margin-top:6px;">
                <label>Surge</label>
                Factor: <input id="surgeFactor" type="number" value="2" style="width:64px" />
                Hours: <input id="surgeHours" type="number" value="6" style="width:64px" />
                <button id="surgeBtn">Trigger</button>
            </div>

            <hr style="border: none; height:1px; background:#0e3244; margin:10px 0;" />

            <div class="row">
                <button id="pause">Pause</button>
                <button id="resume">Resume</button>
                <button id="resetBtn" class="secondary">Reset</button>
            </div>

            <div class="small" id="lastLog"></div>
        </div>

        <div style="flex:1;">
            <canvas id="canvas" width="1000" height="600"></canvas>
            <div class="small muted" style="margin-top:6px;">Camp is fixed in the center. Eye moves relative to camp. Trail shows last positions (fading).</div>
        </div>
    </div>

    <script>
        /* ====== Configuration ====== */
        const API_ROOT = "/Eye";
        const POLL_MS = 2000;                 // poll frequency (ms)
        const TRAIL_MAX = 60;                 // how many past points to keep
        const BASE_EYE_DIAMETER = 50.0;       // km used to map scale
        const BASE_EYE_COVER = 0.85;          // proportion of smallest canvas dim for base diameter (85%)

        /* Exposure grid config */
        const GRID_CELLS_X = 160;             // resolution horizontally (160 => 160*100 operations; tune if needed)
        const GRID_CELLS_Y = 96;              // resolution vertically (keeps roughly same aspect as 1000x600)
        const EXPOSURE_DECAY_PER_SECOND = 0.08; // how fast exposure fades (higher = faster fade)
        const MAX_EXPOSURE = 20.0;            // clamp exposure for color mapping

        /* =========================== */

        let state = null;
        let prevState = null;
        let trail = []; // array of {t: timestamp, X, Y, DiameterKm}
        let initializedCamp = false;

        // exposure grid (float32 for speed)
        let exposure = new Float32Array(GRID_CELLS_X * GRID_CELLS_Y);
        let lastExposureTime = Date.now(); // wall-clock to compute decay

        // UI elements
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const campXInput = document.getElementById("campX");
        const campYInput = document.getElementById("campY");

        /* ===== helpers ===== */
        function safeFetch(url, opts) {
            return fetch(url, opts).then(r => {
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return r.json();
            });
        }

        async function getState() {
            try {
                const s = await safeFetch(API_ROOT);
                return s;
            } catch (e) {
                console.error("Failed to fetch /Eye", e);
                return null;
            }
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        /* ===== Main poll & animate loop ===== */

        async function fetchState() {
            const newState = await getState();
            if (!newState) return;   

            console.log("Received total hours from server:", newState.TotalElapsedHours);

            // shift prev->state
            prevState = state ? { ...state } : null;
            state = newState;

            // initialize camp only ONCE to the Eye center
            if (!initializedCamp) {
                campXInput.value = state.X.toFixed(3);
                campYInput.value = state.Y.toFixed(3);
                initializedCamp = true;
            }

            // append to trail for optional rendering
            trail.push({ t: Date.now(), X: state.X, Y: state.Y, DiameterKm: state.DiameterKm });
            if (trail.length > TRAIL_MAX) trail.shift();
                    

            // accumulate exposure on grid cells covered by Eye for simHours
            accumulateExposure(state, 0.5);

            // animate between prevState -> state to give smooth movement over the poll interval
            animateBetween(prevState, state, POLL_MS);

            // update last log marker
            document.getElementById("lastLog").innerText = `Last polled: ${new Date().toLocaleTimeString()}`;
        }

        /* accumulate exposure onto the grid */
        function accumulateExposure(snap, simHours) {
            if (!snap) return;

            // compute mapping pxPerKm identical to drawCanvas mapping
            const minDim = Math.min(canvas.width, canvas.height);
            const desiredPx = minDim * BASE_EYE_COVER;
            const pxPerKm = desiredPx / BASE_EYE_DIAMETER;

            // world area shown by canvas (in km)
            const worldWidthKm = canvas.width / pxPerKm;
            const worldHeightKm = canvas.height / pxPerKm;

            // camp world coords
            const campX = parseFloat(campXInput.value) || snap.X;
            const campY = parseFloat(campYInput.value) || snap.Y;

            // Eye center relative to camp (in km)
            const eyeRelX = snap.X - campX;
            const eyeRelY = snap.Y - campY;
            const eyeRadiusKm = snap.DiameterKm / 2.0;

            // grid cell size in world km
            const cellKmX = worldWidthKm / GRID_CELLS_X;
            const cellKmY = worldHeightKm / GRID_CELLS_Y;

            // bounding grid indices to iterate
            const minXkm = eyeRelX - eyeRadiusKm;
            const maxXkm = eyeRelX + eyeRadiusKm;
            const minYkm = eyeRelY - eyeRadiusKm;
            const maxYkm = eyeRelY + eyeRadiusKm;

            const minI = Math.max(0, Math.floor((minXkm + worldWidthKm / 2) / cellKmX));
            const maxI = Math.min(GRID_CELLS_X - 1, Math.ceil((maxXkm + worldWidthKm / 2) / cellKmX));
            const minJ = Math.max(0, Math.floor(((-maxYkm) + worldHeightKm / 2) / cellKmY)); // note Y inversion
            const maxJ = Math.min(GRID_CELLS_Y - 1, Math.ceil(((-minYkm) + worldHeightKm / 2) / cellKmY));

            // add exposure: approximate by cell center distance test (fast)
            const addAmount = simHours; // exposure units per sim hour (you can scale)
            for (let j = minJ; j <= maxJ; j++) {
                for (let i = minI; i <= maxI; i++) {
                    const cellCenterWorldX = (i + 0.5) * cellKmX - (worldWidthKm / 2);
                    const cellCenterWorldY = -((j + 0.5) * cellKmY - (worldHeightKm / 2)); // invert back
                    const dx = cellCenterWorldX - eyeRelX;
                    const dy = cellCenterWorldY - eyeRelY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= eyeRadiusKm) {
                        // exposure increment can scale by how deep inside circle (optional)
                        const frac = 1 - (dist / eyeRadiusKm); // center gets higher weight
                        const idx = j * GRID_CELLS_X + i;
                        exposure[idx] = Math.min(MAX_EXPOSURE, exposure[idx] + addAmount * frac);
                    }
                }
            }
        }

        /* animate interpolation */
        function animateBetween(a, b, durationMs) {
            if (!a) { render(b); return; }
            const start = performance.now();
            function frame(now) {
                const t = Math.min(1, (now - start) / durationMs);
                const tmp = {
                    X: lerp(a.X, b.X, t),
                    Y: lerp(a.Y, b.Y, t),
                    DiameterKm: lerp(a.DiameterKm, b.DiameterKm, t),
                    BaseBearing: lerp(a.BaseBearing, b.BaseBearing, t),
                    SpeedKmPerDay: lerp(a.SpeedKmPerDay, b.SpeedKmPerDay, t),
                    ActiveInfluences: b.ActiveInfluences,
                    LastUpdated: b.LastUpdated,
                    TotalElapsedHours: lerp(a.TotalElapsedHours || 0, b.TotalElapsedHours, t)
                };
                render(tmp);
                if (t < 1) requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }

        /* render uses snap (interpolated) */
        function render(snap) {
            const s = snap || state;
            if (!s) return;

            //Checking the TotalElsapsdf
            console.log("Received total hours from renederer:", s.TotalElapsedHours);

            const totalSimulatedHours = s.TotalElapsedHours || 0;
            const days = Math.floor(totalSimulatedHours / 24);
            const hours = Math.floor(totalSimulatedHours % 24);
            document.getElementById("inGameTimeDisplay").innerText = `In-Game Time: ${days} days, ${hours} hours`;

            // metrics
            document.getElementById("metrics").innerHTML = `
            <div class="muted">Eye Pos: (${s.X.toFixed(3)}, ${s.Y.toFixed(3)}) km</div>
            <div class="muted">Bearing: ${s.BaseBearing.toFixed(1)}° • Speed: ${s.SpeedKmPerDay.toFixed(2)} km/day</div>
            <div><strong>Diameter:</strong> ${s.DiameterKm.toFixed(2)} km</div>
            <div class="muted">Influences: ${s.ActiveInfluences.length} • Last: ${new Date(s.LastUpdated).toLocaleTimeString()}</div>
          `;
            drawCanvas(s);
        }

        /* drawCanvas now paints exposure grid first, then Eye, then camp */
        function drawCanvas(snap) {
            // decay exposure based on real time passed
            const now = Date.now();
            const dtSec = Math.max(0, (now - lastExposureTime) / 1000.0);
            lastExposureTime = now;
            if (dtSec > 0) {
                const decayFactor = Math.exp(-EXPOSURE_DECAY_PER_SECOND * dtSec);
                for (let i = 0; i < exposure.length; i++) exposure[i] *= decayFactor;
            }

            // prepare mapping
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const minDim = Math.min(canvas.width, canvas.height);
            const desiredPx = minDim * BASE_EYE_COVER;
            const pxPerKm = desiredPx / BASE_EYE_DIAMETER;
            const worldWidthKm = canvas.width / pxPerKm;
            const worldHeightKm = canvas.height / pxPerKm;

            // camp world coords
            const campX = parseFloat(campXInput.value) || (snap ? snap.X : 0);
            const campY = parseFloat(campYInput.value) || (snap ? snap.Y : 0);

            // draw exposure grid as colored rectangles (fade by exposure)
            const cellW = canvas.width / GRID_CELLS_X;
            const cellH = canvas.height / GRID_CELLS_Y;
            for (let j = 0; j < GRID_CELLS_Y; j++) {
                for (let i = 0; i < GRID_CELLS_X; i++) {
                    const idx = j * GRID_CELLS_X + i;
                    const val = exposure[idx];
                    if (val <= 0.0001) continue; // skip blank
                    // map exposure to color intensity [0..1]
                    const t = Math.min(1, val / MAX_EXPOSURE);
                    // color ramp (dark -> molten gold): you can tweak
                    const r = Math.floor(150 + t * 105);   // 150 -> 255
                    const g = Math.floor(120 + t * 80);    // 120 -> 200
                    const b = Math.floor(60 + t * 40);     // 60 -> 100
                    const alpha = 0.06 + 0.5 * t;          // base faint + more with exposure
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    const px = i * cellW;
                    const py = j * cellH;
                    ctx.fillRect(px, py, Math.ceil(cellW) + 1, Math.ceil(cellH) + 1);
                }
            }

            // draw current Eye
            const eyeXpx = cx + (snap.X - campX) * pxPerKm;
            const eyeYpx = cy - (snap.Y - campY) * pxPerKm;
            const radius = Math.max(2, (snap.DiameterKm / 2) * pxPerKm);

            // Eye fill + stroke
            ctx.beginPath();
            ctx.arc(eyeXpx, eyeYpx, radius, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(200,150,80,0.12)";
            ctx.fill();
            ctx.lineWidth = Math.max(1, Math.min(14, snap.SpeedKmPerDay / 1.5));
            ctx.strokeStyle = "rgba(200,150,80,0.75)";
            ctx.stroke();

            // Eye center marker
            ctx.beginPath();
            ctx.arc(eyeXpx, eyeYpx, 6, 0, Math.PI * 2);
            ctx.fillStyle = "#ffd880";
            ctx.fill();
            ctx.fillStyle = "#000";
            ctx.font = "12px Arial";
            ctx.fillText("Eye Center", eyeXpx + 10, eyeYpx + 4);

            // North Indicator
            const northLen = Math.max(20, radius * 0.25);
            ctx.beginPath();
            ctx.moveTo(eyeXpx, eyeYpx);
            ctx.lineTo(eyeXpx, eyeYpx - northLen); // Straight up
            ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 3]); // Make it a dashed line
            ctx.stroke();
            ctx.setLineDash([]); // Reset to solid lines
            ctx.font = "10px Arial";
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.fillText("N", eyeXpx + 4, eyeYpx - northLen - 4);

            // Bearing Arrow (shows intended vector)
            const bearingRad = (90 - snap.BaseBearing) * Math.PI / 180;
            const arrowLen = Math.max(40, radius * 0.45);
            ctx.beginPath();
            ctx.moveTo(eyeXpx, eyeYpx);
            // We invert the Y-component by subtracting the sine value.
            ctx.lineTo(eyeXpx + Math.cos(bearingRad) * arrowLen, eyeYpx - Math.sin(bearingRad) * arrowLen);
            ctx.strokeStyle = "#88c0ff"; // Blue for the intended vector
            ctx.lineWidth = 3;
            ctx.stroke();

            // camp marker at center
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fillStyle = "#ff6b6b";
            ctx.fill();
            ctx.fillStyle = "#ffe";
            ctx.font = "13px Arial";
            ctx.fillText("Camp (you)", cx + 12, cy + 5);

            // debug: pixel delta
            if (prevState) {
                const prevXpx = cx + (prevState.X - campX) * pxPerKm;
                const prevYpx = cy - (prevState.Y - campY) * pxPerKm;
                const dxpx = (eyeXpx - prevXpx).toFixed(3);
                const dypx = (eyeYpx - prevYpx).toFixed(3);
                ctx.fillStyle = "#9fb7cc";
                ctx.font = "12px Arial";
                ctx.fillText(`Δpx: ${dxpx}, ${dypx}`, 10, canvas.height - 12);
            }
        }

        /* ========== Button Handlers (same wiring) ========== */
        document.getElementById("centerCamp").addEventListener("click", () => {
            if (!state) return;
            campXInput.value = state.X.toFixed(3);
            campYInput.value = state.Y.toFixed(3);
            render();
        });

        document.getElementById("setDiameterBtn").addEventListener("click", async () => {
            const d = parseFloat(document.getElementById("setDiameter").value) || 50;
            await safePost(`${API_ROOT}/setDiameter`, { DiameterKm: d });
            await fetchState();
        });

        document.getElementById("shrinkOverBtn").addEventListener("click", async () => {
            const target = parseFloat(document.getElementById("shrinkTarget").value) || 30;
            const hours = parseInt(document.getElementById("shrinkHours").value) || 12;
            await safePost(`${API_ROOT}/shrink-over-time`, { TargetDiameterKm: target, DurationHours: hours });
            await fetchState();
        });

        document.getElementById("shrinkNow").addEventListener("click", async () => {
            const pct = parseFloat(document.getElementById("shrinkPercent").value) || 10;
            if (!state) await fetchState();
            const cur = state.DiameterKm;
            const target = Math.max(0.1, cur * (1 - pct / 100));
            await safePost(`${API_ROOT}/setDiameter`, { DiameterKm: target });
            await fetchState();
        });

        document.getElementById("advanceDay").addEventListener("click", async () => {
            await safePost(`${API_ROOT}/advance`, { Hours: 24 });
            await fetchState();
        });

        document.getElementById("jumpDaysBtn").addEventListener("click", async () => {
            const days = parseFloat(document.getElementById("jumpDays").value) || 1;
            await safePost(`${API_ROOT}/jumpDays`, { Days: days });
            await fetchState();
        });

        document.getElementById("applyInf").addEventListener("click", async () => {
            const name = document.getElementById("infName").value || undefined;
            const dir = parseFloat(document.getElementById("infDir").value) || 0;
            const mag = parseFloat(document.getElementById("infMag").value) || 1;
            const dur = parseFloat(document.getElementById("infDur").value) || 24;
            await safePost(`${API_ROOT}/applyInfluence`, { Name: name, DirectionDeg: dir, MagnitudeKmPerDay: mag, DurationHours: dur });
            await fetchState();
        });

        document.getElementById("setBase").addEventListener("click", async () => {
            const bearing = parseFloat(document.getElementById("baseBearing").value) || 90;
            const speed = parseFloat(document.getElementById("baseSpeed").value) || 12;
            await safePost(`${API_ROOT}/setBase`, { BearingDeg: bearing, SpeedKmPerDay: speed });
            await fetchState();
        });

        document.getElementById("surgeBtn").addEventListener("click", async () => {
            const factor = parseFloat(document.getElementById("surgeFactor").value) || 2;
            const hours = parseFloat(document.getElementById("surgeHours").value) || 6;
            await safePost(`${API_ROOT}/surge`, { Factor: factor, DurationHours: hours, Name: "dash" });
            await fetchState();
        });

        document.getElementById("pause").addEventListener("click", async () => {
            await safePost(`${API_ROOT}/pause`, {});
            await fetchState();
        });
        document.getElementById("resume").addEventListener("click", async () => {
            await safePost(`${API_ROOT}/resume`, {});
            await fetchState();
        });

        document.getElementById("resetBtn").addEventListener("click", async () => {
            const payload = {
                X: parseFloat(campXInput.value) || 0,
                Y: parseFloat(campYInput.value) || 0,
                BaseBearing: parseFloat(document.getElementById("baseBearing").value) || 90,
                SpeedKmPerDay: parseFloat(document.getElementById("baseSpeed").value) || 12,
                DriftVarianceDeg: 5.0,
                JitterFraction: 0.08,
                CourseShiftChancePerDay: 0.03,
                PredictabilityRating: 3
            };
            await safePost(`${API_ROOT}/reset`, payload);
            await fetchState();
        });

        /* ===== HTTP helper wrappers ===== */
        async function safePost(url, body) {
            try {
                const r = await fetch(url, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(body) });
                if (!r.ok) {
                    const txt = await r.text();
                    console.error("POST failed", r.status, txt);
                    alert("Server error: " + r.status + (txt ? ("\n" + txt) : ""));
                } else {
                    return await r.json();
                }
            } catch (e) {
                console.error("Network POST failed", e);
            }
        }

        /* ===== Polling loop ===== */
        setInterval(fetchState, POLL_MS);
        fetchState(); // initial
    </script>

</body>
</html>