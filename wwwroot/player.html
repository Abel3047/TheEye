<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>The Eye — Player View</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        /* CSS is identical to index.html, so it's included for brevity */
        :root {
            --panel-bg: #071827;
            --accent: #ffd880;
            --muted: #9fb7cc;
            --bg: #0b0b0f;
        }

        body {
            font-family: system-ui, Arial;
            margin: 12px;
            background: var(--bg);
            color: #e6eef8;
        }

        h2 {
            margin: 0 0 10px 0;
        }

        #wrap {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .panel {
            background: var(--panel-bg);
            padding: 12px;
            border-radius: 8px;
            min-width: 240px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.6);
        }

        .small {
            font-size: 12px;
            color: var(--muted);
            margin-top: 6px;
        }

        #canvas {
            border-radius: 6px;
            display: block;
            background: #061426;
            border: 1px solid #234;
            margin-top: 12px;
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h2>The Eye — Player View</h2>

    <div id="wrap">
        <div class="panel">
            <div><strong>Eye Metrics</strong></div>
            <div id="metrics" class="small">loading…</div>
            <hr style="border: none; height:1px; background:#0e3244; margin:10px 0;" />
            <div class="small" id="inGameTimeDisplay">In-Game Time: loading...</div>
        </div>

        <div style="flex:1;">
            <canvas id="canvas" width="1000" height="600"></canvas>
            <div class="small muted" style="margin-top:6px;">Camp is fixed in the center. Eye moves relative to camp.</div>
        </div>
    </div>

    <script>
        /* ====== Configuration ====== */
        const API_ROOT = "/Eye"; // This still points to the public GET endpoint
        const POLL_MS = 2000;
        const TRAIL_MAX = 60;
        const BASE_EYE_DIAMETER = 50.0;
        const BASE_EYE_COVER = 0.85;
        const GRID_CELLS_X = 160;
        const GRID_CELLS_Y = 96;
        const EXPOSURE_DECAY_PER_SECOND = 0.08;
        const MAX_EXPOSURE = 20.0;

        /* =========================== */

        let state = null;
        let prevState = null;
        let trail = [];
        let initializedCamp = false;
        let exposure = new Float32Array(GRID_CELLS_X * GRID_CELLS_Y);
        let lastExposureTime = Date.now();

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        // We need a camp position to render, but players can't change it.
        // We will receive it from the initial state fetch.
        let campX = 0;
        let campY = 0;
             
        async function getState() {
            try {
                const r = await fetch(API_ROOT);
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return await r.json();
            } catch (e) {
                console.error("Failed to fetch state", e);
                return null;
            }
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        /* ===== Main poll & animate loop ===== */
        async function fetchState() {
            const fullState = await getState();
            if (!fullState) return; 

            prevState = state ? { ...state } : null;
            state = fullState.eye;

            campX = fullState.campX;
            campY = fullState.campY;

            trail.push({ t: Date.now(), X: state.X, Y: state.Y, DiameterKm: state.DiameterKm });
            if (trail.length > TRAIL_MAX) trail.shift();

            accumulateExposure(state, 0.5);
            animateBetween(prevState, state, POLL_MS);
        }

        /* accumulate exposure onto the grid */
        function accumulateExposure(snap, simHours) {
            if (!snap) return;

            // compute mapping pxPerKm identical to drawCanvas mapping
            const minDim = Math.min(canvas.width, canvas.height);
            const desiredPx = minDim * BASE_EYE_COVER;
            const pxPerKm = desiredPx / BASE_EYE_DIAMETER;

            // world area shown by canvas (in km)
            const worldWidthKm = canvas.width / pxPerKm;
            const worldHeightKm = canvas.height / pxPerKm;

            // Eye center relative to camp (in km)
            const eyeRelX = snap.X - campX;
            const eyeRelY = snap.Y - campY;
            const eyeRadiusKm = snap.DiameterKm / 2.0;

            // grid cell size in world km
            const cellKmX = worldWidthKm / GRID_CELLS_X;
            const cellKmY = worldHeightKm / GRID_CELLS_Y;

            // bounding grid indices to iterate
            const minXkm = eyeRelX - eyeRadiusKm;
            const maxXkm = eyeRelX + eyeRadiusKm;
            const minYkm = eyeRelY - eyeRadiusKm;
            const maxYkm = eyeRelY + eyeRadiusKm;

            const minI = Math.max(0, Math.floor((minXkm + worldWidthKm / 2) / cellKmX));
            const maxI = Math.min(GRID_CELLS_X - 1, Math.ceil((maxXkm + worldWidthKm / 2) / cellKmX));
            const minJ = Math.max(0, Math.floor(((-maxYkm) + worldHeightKm / 2) / cellKmY)); // note Y inversion
            const maxJ = Math.min(GRID_CELLS_Y - 1, Math.ceil(((-minYkm) + worldHeightKm / 2) / cellKmY));

            // add exposure: approximate by cell center distance test (fast)
            const addAmount = simHours; // exposure units per sim hour (you can scale)
            for (let j = minJ; j <= maxJ; j++) {
                for (let i = minI; i <= maxI; i++) {
                    const cellCenterWorldX = (i + 0.5) * cellKmX - (worldWidthKm / 2);
                    const cellCenterWorldY = -((j + 0.5) * cellKmY - (worldHeightKm / 2)); // invert back
                    const dx = cellCenterWorldX - eyeRelX;
                    const dy = cellCenterWorldY - eyeRelY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= eyeRadiusKm) {
                        // exposure increment can scale by how deep inside circle (optional)
                        const frac = 1 - (dist / eyeRadiusKm); // center gets higher weight
                        const idx = j * GRID_CELLS_X + i;
                        exposure[idx] = Math.min(MAX_EXPOSURE, exposure[idx] + addAmount * frac);
                    }
                }
            }
        }

        /* animate interpolation */
        function animateBetween(a, b, durationMs) {
            if (!a) { render(b); return; }
            const start = performance.now();
            function frame(now) {
                const t = Math.min(1, (now - start) / durationMs);
                const tmp = {
                    X: lerp(a.X, b.X, t),
                    Y: lerp(a.Y, b.Y, t),
                    DiameterKm: lerp(a.DiameterKm, b.DiameterKm, t),
                    BaseBearing: lerp(a.BaseBearing, b.BaseBearing, t),
                    SpeedKmPerDay: lerp(a.SpeedKmPerDay, b.SpeedKmPerDay, t),
                    ActiveInfluences: b.ActiveInfluences,
                    LastUpdated: b.LastUpdated,
                    TotalElapsedHours: lerp(a.TotalElapsedHours || 0, b.TotalElapsedHours, t)
                };
                render(tmp);
                if (t < 1) requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }

        /* render uses snap (interpolated) */
        function render(snap) {
            const s = snap || state;
            if (!s) return;

            //Checking the TotalElsapsdf
            console.log("Received total hours from renederer:", s.TotalElapsedHours);

            const totalSimulatedHours = s.TotalElapsedHours || 0;
            const days = Math.floor(totalSimulatedHours / 24);
            const hours = Math.floor(totalSimulatedHours % 24);
            document.getElementById("inGameTimeDisplay").innerText = `In-Game Time: ${days} days, ${hours} hours`;

            // metrics
            document.getElementById("metrics").innerHTML = `
      <div class="muted">Eye Pos: (${s.X.toFixed(3)}, ${s.Y.toFixed(3)}) km</div>
      <div class="muted">Bearing: ${s.BaseBearing.toFixed(1)}° • Speed: ${s.SpeedKmPerDay.toFixed(2)} km/day</div>
      <div><strong>Diameter:</strong> ${s.DiameterKm.toFixed(2)} km</div>
      <div class="muted">Influences: ${s.ActiveInfluences.length} • Last: ${new Date(s.LastUpdated).toLocaleTimeString()}</div>
    `;
            drawCanvas(s);
        }

        /* drawCanvas now paints exposure grid first, then Eye, then camp */
        function drawCanvas(snap) {
            // decay exposure based on real time passed
            const now = Date.now();
            const dtSec = Math.max(0, (now - lastExposureTime) / 1000.0);
            lastExposureTime = now;
            if (dtSec > 0) {
                const decayFactor = Math.exp(-EXPOSURE_DECAY_PER_SECOND * dtSec);
                for (let i = 0; i < exposure.length; i++) exposure[i] *= decayFactor;
            }

            // prepare mapping
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const minDim = Math.min(canvas.width, canvas.height);
            const desiredPx = minDim * BASE_EYE_COVER;
            const pxPerKm = desiredPx / BASE_EYE_DIAMETER;            

            // draw exposure grid as colored rectangles (fade by exposure)
            const cellW = canvas.width / GRID_CELLS_X;
            const cellH = canvas.height / GRID_CELLS_Y;
            for (let j = 0; j < GRID_CELLS_Y; j++) {
                for (let i = 0; i < GRID_CELLS_X; i++) {
                    const idx = j * GRID_CELLS_X + i;
                    const val = exposure[idx];
                    if (val <= 0.0001) continue; // skip blank
                    // map exposure to color intensity [0..1]
                    const t = Math.min(1, val / MAX_EXPOSURE);
                    // color ramp (dark -> molten gold): you can tweak
                    const r = Math.floor(150 + t * 105);   // 150 -> 255
                    const g = Math.floor(120 + t * 80);    // 120 -> 200
                    const b = Math.floor(60 + t * 40);     // 60 -> 100
                    const alpha = 0.06 + 0.5 * t;          // base faint + more with exposure
                    ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                    const px = i * cellW;
                    const py = j * cellH;
                    ctx.fillRect(px, py, Math.ceil(cellW) + 1, Math.ceil(cellH) + 1);
                }
            }

            // draw current Eye
            const eyeXpx = cx + (snap.X - campX) * pxPerKm;
            const eyeYpx = cy - (snap.Y - campY) * pxPerKm;
            const radius = Math.max(2, (snap.DiameterKm / 2) * pxPerKm);

            // Eye fill + stroke
            ctx.beginPath();
            ctx.arc(eyeXpx, eyeYpx, radius, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(200,150,80,0.12)";
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(200,150,80,0.75)";
            ctx.stroke();

            // Eye center marker
            ctx.beginPath();
            ctx.arc(eyeXpx, eyeYpx, 6, 0, Math.PI * 2);
            ctx.fillStyle = "#ffd880";
            ctx.fill();
            ctx.fillStyle = "#000";
            ctx.font = "12px Arial";
            ctx.fillText("Eye Center", eyeXpx + 10, eyeYpx + 4);

            // North Indicator
            const northLen = Math.max(20, radius * 0.25);
            ctx.beginPath();
            ctx.moveTo(eyeXpx, eyeYpx);
            ctx.lineTo(eyeXpx, eyeYpx - northLen); // Straight up
            ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 3]); // Make it a dashed line
            ctx.stroke();
            ctx.setLineDash([]); // Reset to solid lines
            ctx.font = "10px Arial";
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.fillText("N", eyeXpx + 4, eyeYpx - northLen - 4);

            // Bearing Arrow (shows intended vector)
            const bearingRad = (90 - snap.BaseBearing) * Math.PI / 180;
            const arrowLen = 35 + (snap.SpeedKmPerDay * 3);
            ctx.beginPath();
            ctx.moveTo(eyeXpx, eyeYpx);
            // We invert the Y-component by subtracting the sine value.
            ctx.lineTo(eyeXpx + Math.cos(bearingRad) * arrowLen, eyeYpx - Math.sin(bearingRad) * arrowLen);
            ctx.strokeStyle = "#88c0ff"; // Blue for the intended vector
            ctx.lineWidth = 3;
            ctx.stroke();

            // camp marker at center
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fillStyle = "#ff6b6b";
            ctx.fill();
            ctx.fillStyle = "#ffe";
            ctx.font = "13px Arial";
            ctx.fillText("Camp (you)", cx + 12, cy + 5);

            // debug: pixel delta
            if (prevState) {
                const prevXpx = cx + (prevState.X - campX) * pxPerKm;
                const prevYpx = cy - (prevState.Y - campY) * pxPerKm;
                const dxpx = (eyeXpx - prevXpx).toFixed(3);
                const dypx = (eyeYpx - prevYpx).toFixed(3);
                ctx.fillStyle = "#9fb7cc";
                ctx.font = "12px Arial";
                ctx.fillText(`Δpx: ${dxpx}, ${dypx}`, 10, canvas.height - 12);
            }
        }

        /* ===== Polling loop ===== */
        setInterval(fetchState, POLL_MS);
        fetchState(); // initial
    </script>
</body>
</html>